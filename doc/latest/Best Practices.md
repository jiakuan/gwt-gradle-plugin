# Best Practices

GWT has a long history and has proven to be reliable for compiling Java code into optimized JavaScript. As browser technology, the JavaScript ecosystem, and Gradle continue to evolve rapidly, the best way to use this GWT Gradle plugin is to adapt accordingly.

This page is dedicated to documenting the latest best practices.

## GWT Dependencies

### Transitive Dependencies

`gwt-dev` brings 55 additional JAR files with it. 32 of them contain reported vulnerabilities, totaling at 246 CVEs. The last GWT release (2.11 -> 2.12.1) did not update a single one of these dependencies. (For details, see https://github.com/vmj/gwt-dev-vulnerabilities)

### Dev Dependencies

During development you need

- `gwt-user.jar` (JRE emulation, Widgets, etc)
- `gwt-dev.jar` (compiler, dev mode)
- `gwt-codeserver.jar` (Jetty based server that calls GWT compiler and serves the compile output. Depends on gwt-dev.jar)
- Any 3rd party GWT library (e.g. GWT UI Frameworks, elemental2)

Non of these should ever be deployed in a `*.war` file.

### Runtime Dependencies

If needed, you only need to deploy (and their transitive dependencies):

- `gwt-servlet.jar` / gwt-servlet-jakarta.jar, if you use GWT-RPC
- `requestfactory-server.jar`, if you use RequestFactory


## Project Structure

### Single Project Setup

If you create a gradle project with just a single module that combines GWT and web application then you have the above problem, because now you only have a single classpath for GWT compilation and for your web application. E.g. your build.gradle file looks like:

``` 
plugins {
  id 'war'
  id 'org.docstr.gwt'
}
```

In that case you would need a dedicated configuration, e.g. named gwt, put all GWT dependencies into that gwt configuration and use the configuration to populate the classpath of any GWT related task (SuperDevMode, DevMode, GWT compile). 

### Multi-Module Project

A better setup is to split that single gradle module into two gradle modules, e.g. gwt-ui and webapp, and then include the various GWT compiler outputs of gwt-ui in the war task of the webapp module. Then you automatically have two dedicated classpaths and you can put all GWT related dependencies in the gwt-ui module in scope implementation.

Once you have two gradle modules you need to figure out a way to share the gwt compiler outputs of gwt-ui module with the webapp modules war task. To do so you should use configurations, see below.

multi-module-project/settings.gradle:

``` 
rootProject.name = 'multi-module-project'

include ':gwt-ui'
include ':webapp'
```

multi-module-project/gwt-ui/build.gradle:

```
plugins {
    id 'java'
    id "org.docstr.gwt" version "2.1.6"
}

group = 'com.example.gwt'
version = '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
   // your GWT dependencies, e.g. guava-gwt
   // implementation "..."
}

gwt {
    modules = ['com.example.gwt.GwtUi']
    // Relocate some GWT outputs so they each have a dedicated folder.
    // This works better when sharing the GWT output with other projects because
    // you can precisely control what to share.

    // The final JS App (optional configurations below)
    war = file("${layout.buildDirectory}/gwt/war")
    // Server side GWT data, e.g. symbol maps, sourcemaps
    deploy = file("${layout.buildDirectory}/gwt/deploy")
    // Source files generated by GWT compiler
    gen = file("${layout.buildDirectory}/gwt/gen")
    // Compile report as information for the GWT developer
    extra = file("${layout.buildDirectory}/gwt/extra")
}

// Additional configurations each holding a single zip file with
// the corresponding GWT compiler output.
configurations {
    gwtJsZipFile
    gwtDeployZipFile
}

// Zip task to package GWT JS output
tasks.register("zipGwtJs", Zip) {
    dependsOn("gwtCompile")
    from (gwt.war)
    destinationDirectory = layout.buildDirectory.dir('gwt')
    archiveBaseName = "${project.name}-js"
}

// Zip task to package GWT deploy output
tasks.register("zipGwtDeploy", Zip) {
    dependsOn("gwtCompile")
    from (gwt.deploy)
    destinationDirectory = layout.buildDirectory.dir('gwt')
    archiveBaseName = "${project.name}-deploy"
}

// Add each zip file as artifact to its corresponding configuration.
// These can then be consumed by other projects.
artifacts {
    gwtJsZipFile tasks.named("zipGwtJs")
    gwtDeployZipFile tasks.named("zipGwtDeploy")
}
```

multi-module-project/webapp/build.gradle:

```
plugins {
    id 'java'
    id 'war'
}

group = 'com.example.gwt'
version = '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

// Additional configurations that each will hold a single zip file
// with the corresponding GWT compiler output
configurations {
    gwtJsZipFile
    gwtDeployZipFile
}

dependencies {
    // web app dependencies
    compileOnly 'javax.servlet:javax.servlet-api:3.1.0'

    // Depend on the zip files produced by 'gwt-ui' module by depending
    // on the corresponding configurations.
    // These should be unzipped into the final war file
    gwtJsZipFile project(path: ':gwt-ui', configuration: 'gwtJsZipFile')
    gwtDeployZipFile project(path: ':gwt-ui', configuration: 'gwtDeployZipFile')
}

war {
    // Ensure that 'gwt-ui' has been compiled and zip files are ready
    dependsOn(configurations.gwtJsZipFile)
    dependsOn(configurations.gwtDeployZipFile)
    // include the JS app to the root of the war file
    into ('/') {
        from zipTree(configurations.gwtJsZipFile.singleFile)
    }
    // include the deploy files to WEB-INF/deploy as they are only used by the server,
    // e.g. during client exception stack trace deobfuscation (if the JS app sends the
    // stack trace to the server)
    into ('WEB-INF/deploy') {
        from zipTree(configurations.gwtDeployZipFile.singleFile)
    }
}
```

With the above the final war file will never have any GWT libaries packaged because it only depends on the GWT JS output. An alternative to using Gradle configurations is to use Gradle variants but I think configurations are a bit easier to setup and are good enough in this situation here.

If you are not building a war file or using other backend technology instead of Java, you can configure the JS output directory directly pointing to your frontend folder:

```
gwt {
    // ... other gwt configurations
    war = file('../my-frontend/scripts')
}
```
